---
title: Entendendo o desempenho da realidade misturada
description: Tópicos avançados e detalhes sobre como otimizar o desempenho para aplicativos do Windows Mixed Reality
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Realidade mista do Windows, realidade misturada, realidade virtual, VR, Sr, desempenho, otimização, CPU, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548837"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="c1dc2-104">Entendendo o desempenho da realidade misturada</span><span class="sxs-lookup"><span data-stu-id="c1dc2-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="c1dc2-105">Este artigo é uma introdução à racionalização do significado do desempenho para seu aplicativo de realidade misturada.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="c1dc2-106">A experiência do usuário pode ser bastante degradada se seu aplicativo não for executado em uma taxa de quadros ideal.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="c1dc2-107">Os hologramas aparecerão instáveis e o controle de carga do ambiente não será preciso, levando a uma experiência ruim para o usuário.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="c1dc2-108">Na verdade, o desempenho deve ser considerado como um recurso de primeira classe para o desenvolvimento de realidade misturada e não uma tarefa de fim de ciclo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="c1dc2-109">Para revisão, os valores de taxa de quadros de alto desempenho para cada plataforma de destino são listados abaixo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="c1dc2-110">Plataforma</span><span class="sxs-lookup"><span data-stu-id="c1dc2-110">Platform</span></span> | <span data-ttu-id="c1dc2-111">Taxa de quadros de destino</span><span class="sxs-lookup"><span data-stu-id="c1dc2-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="c1dc2-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="c1dc2-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="c1dc2-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="c1dc2-113">60 FPS</span></span> |
| [<span data-ttu-id="c1dc2-114">Windows Mixed Reality ultra PCs</span><span class="sxs-lookup"><span data-stu-id="c1dc2-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="c1dc2-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="c1dc2-115">90 FPS</span></span> |
| [<span data-ttu-id="c1dc2-116">Computadores Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="c1dc2-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="c1dc2-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="c1dc2-117">60 FPS</span></span> |

<span data-ttu-id="c1dc2-118">A estrutura a seguir fornece uma estrutura geral para práticas recomendadas e entendimentos para atingir as taxas de quadros de destino.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="c1dc2-119">Para aprofundar-se nos detalhes, considere ler o [artigo recomendações de desempenho para o Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="c1dc2-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="c1dc2-120">Em particular, este artigo relacionado discutirá como medir a taxa de quadros em seu aplicativo do Unity Windows Mixed Reality, bem como as etapas a serem executadas no ambiente do Unity para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="c1dc2-121">Noções básicas sobre afunilamentos de desempenho</span><span class="sxs-lookup"><span data-stu-id="c1dc2-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="c1dc2-122">Se seu aplicativo tiver uma taxa de quadros com desempenho alto, a primeira etapa será analisar e entender onde o aplicativo é computacionalmente intensivo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="c1dc2-123">Há dois processadores principais responsáveis pelo trabalho de renderizar sua cena: a CPU e a GPU.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="c1dc2-124">Cada um desses dois componentes lida com operações e estágios diferentes de seu aplicativo de realidade misturada.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="c1dc2-125">Há três locais principais onde os afunilamentos podem ocorrer.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="c1dc2-126">**Thread de aplicativo-CPU** -esse thread é responsável pela lógica do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="c1dc2-127">Isso inclui o processamento de entrada, animações, física e outra lógica/estado do aplicativo</span><span class="sxs-lookup"><span data-stu-id="c1dc2-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="c1dc2-128">**Renderizar thread-CPU para GPU** -esse thread é responsável por enviar suas chamadas de desenho para a GPU.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="c1dc2-129">Quando seu aplicativo deseja renderizar um objeto, como um cubo ou modelo, esse thread envia uma solicitação para a GPU, que tem uma arquitetura otimizada para renderização, para executar essas operações.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="c1dc2-130">**GPU** - 
    Esse processador geralmente manipula a pipeline gráfica de seu aplicativo para transformar dados 3D (modelos, texturas, etc.) em pixels e, por fim, produzir uma imagem 2D para enviar à tela do dispositivo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Tempo de vida de um quadro](images/lifetime-of-a-frame.png)

<span data-ttu-id="c1dc2-132">Em geral, os aplicativos do HoloLens serão ligados à GPU.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="c1dc2-133">No entanto, isso não é verdadeiro em todos os aplicativos e, portanto, é recomendável usar as ferramentas & técnicas abaixo para chegar à verdade para o seu aplicativo em particular.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="c1dc2-134">Como analisar seu aplicativo</span><span class="sxs-lookup"><span data-stu-id="c1dc2-134">How to analyze your application</span></span>

<span data-ttu-id="c1dc2-135">Há muitas ferramentas que permitem que você como desenvolvedor entenda o perfil de desempenho do seu aplicativo de realidade misturada.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="c1dc2-136">Eles permitirão que você faça o destino onde você tem gargalos e como eles se manifestam para depurá-los.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="c1dc2-137">Esta é uma lista de ferramentas populares e poderosas para obter informações aprofundadas de criação de perfil para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="c1dc2-138">Analisadores de desempenho de gráficos Intel</span><span class="sxs-lookup"><span data-stu-id="c1dc2-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="c1dc2-139">Depuradores de gráficos do Visual Studio</span><span class="sxs-lookup"><span data-stu-id="c1dc2-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="c1dc2-140">Criador de perfil do Unity</span><span class="sxs-lookup"><span data-stu-id="c1dc2-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="c1dc2-141">Depurador de quadros do Unity</span><span class="sxs-lookup"><span data-stu-id="c1dc2-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="c1dc2-142">Como criar um perfil em qualquer ambiente</span><span class="sxs-lookup"><span data-stu-id="c1dc2-142">How to profile in any environment</span></span>

<span data-ttu-id="c1dc2-143">Há um teste simples para determinar rapidamente se você provavelmente está ligado à GPU ou à CPU limitada em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="c1dc2-144">Se você diminuir a resolução da saída de destino de renderização, haverá menos pixels para calcular e, portanto, menos trabalho que a GPU precisa executar para renderizar uma imagem.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="c1dc2-145">O dimensionamento de visor (dimensionamento de resolução dinâmica) é a prática de renderizar a imagem para um destino de renderização menor, e o dispositivo de saída pode ser exibido.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="c1dc2-146">O dispositivo terá um exemplo de um conjunto menor de pixels para exibir a imagem final.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="c1dc2-147">Depois de diminuir a resolução de renderização, se:</span><span class="sxs-lookup"><span data-stu-id="c1dc2-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="c1dc2-148">**Aumento**da taxa de quadros do aplicativo; provavelmente, você está **vinculado à GPU**</span><span class="sxs-lookup"><span data-stu-id="c1dc2-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="c1dc2-149">Taxa de quadros do aplicativo inalterada, provavelmente você está **limitado à CPU**</span><span class="sxs-lookup"><span data-stu-id="c1dc2-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="c1dc2-150">O Unity fornece a capacidade de modificar facilmente a resolução de destino de renderização de seu aplicativo em tempo de execução por meio da propriedade *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* .</span><span class="sxs-lookup"><span data-stu-id="c1dc2-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="c1dc2-151">A imagem final apresentada no dispositivo tem uma resolução fixa.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="c1dc2-152">A plataforma obterá uma amostra da saída de resolução mais baixa para criar uma imagem de resolução mais alta para renderização em exibições.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="c1dc2-153">Como melhorar seu aplicativo</span><span class="sxs-lookup"><span data-stu-id="c1dc2-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="c1dc2-154">Recomendações de desempenho da CPU</span><span class="sxs-lookup"><span data-stu-id="c1dc2-154">CPU performance recommendations</span></span>

<span data-ttu-id="c1dc2-155">Em geral, a maior parte do trabalho em um aplicativo de realidade misturada na CPU envolve a execução da "simulação" da cena e o processamento de uma lógica de aplicativo extensivamente exclusiva.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="c1dc2-156">Portanto, as áreas a seguir geralmente são destinadas à otimização.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="c1dc2-157">Animations</span><span class="sxs-lookup"><span data-stu-id="c1dc2-157">Animations</span></span>
- <span data-ttu-id="c1dc2-158">Simplificar a física</span><span class="sxs-lookup"><span data-stu-id="c1dc2-158">Simplify Physics</span></span>
- <span data-ttu-id="c1dc2-159">Alocações de memória</span><span class="sxs-lookup"><span data-stu-id="c1dc2-159">Memory allocations</span></span>
- <span data-ttu-id="c1dc2-160">Algoritmos complexos (ou seja,</span><span class="sxs-lookup"><span data-stu-id="c1dc2-160">Complex algorithms (i.e</span></span> <span data-ttu-id="c1dc2-161">cinemática inversa, localização de caminho)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="c1dc2-162">Recomendações de desempenho de GPU</span><span class="sxs-lookup"><span data-stu-id="c1dc2-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="c1dc2-163">Noções básicas sobre largura de banda vs. taxa de preenchimento</span><span class="sxs-lookup"><span data-stu-id="c1dc2-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="c1dc2-164">Ao renderizar um quadro na GPU, um aplicativo geralmente é limitado pela largura de banda da memória ou pela taxa de preenchimento.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="c1dc2-165">**Largura de banda de memória** é a taxa de leituras e gravações que a GPU pode executar da memória</span><span class="sxs-lookup"><span data-stu-id="c1dc2-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="c1dc2-166">Para identificar limitações de largura de banda, reduza a qualidade da textura e verifique se a taxa de quadros melhorou</span><span class="sxs-lookup"><span data-stu-id="c1dc2-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="c1dc2-167">No Unity, isso pode ser feito alterando **a qualidade da textura** em **Editar** > **configurações** > do projeto configurações de **[qualidade](https://docs.unity3d.com/Manual/class-QualitySettings.html)** .</span><span class="sxs-lookup"><span data-stu-id="c1dc2-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="c1dc2-168">A **taxa de preenchimento** refere-se à taxa de transferência de pixels renderizados que podem ser desenhados por segundo pela GPU.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="c1dc2-169">Para identificar as limitações da taxa de preenchimento, diminua a resolução de vídeo e verifique se a taxa de quadros foi aprimorada.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="c1dc2-170">No Unity, isso pode ser feito por meio da propriedade *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*</span><span class="sxs-lookup"><span data-stu-id="c1dc2-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="c1dc2-171">A largura de banda de memória geralmente envolve otimizações para</span><span class="sxs-lookup"><span data-stu-id="c1dc2-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="c1dc2-172">diminuir as resoluções de textura</span><span class="sxs-lookup"><span data-stu-id="c1dc2-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="c1dc2-173">utilizar menos texturas (ou seja,</span><span class="sxs-lookup"><span data-stu-id="c1dc2-173">utilize less textures (i.e</span></span> <span data-ttu-id="c1dc2-174">Normals, especular etc.)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-174">normals, specular, etc)</span></span>

<span data-ttu-id="c1dc2-175">A taxa de preenchimento se concentra principalmente na redução do número de operações que precisam ser computadas para um pixel renderizado final.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="c1dc2-176">Exemplos disso normalmente se enquadram na redução</span><span class="sxs-lookup"><span data-stu-id="c1dc2-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="c1dc2-177">número de objetos a serem renderizados/processados</span><span class="sxs-lookup"><span data-stu-id="c1dc2-177">number of objects to render/process</span></span>
2) <span data-ttu-id="c1dc2-178">número de operações por sombreador</span><span class="sxs-lookup"><span data-stu-id="c1dc2-178">number of operations per shader</span></span>
3) <span data-ttu-id="c1dc2-179">número de estágios de GPU para o resultado final (sombreadores de geometria, efeitos de pós-processamento, etc)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="c1dc2-180">número de pixels a serem renderizados (ou seja,</span><span class="sxs-lookup"><span data-stu-id="c1dc2-180">number of pixels to render (i.e</span></span> <span data-ttu-id="c1dc2-181">resolução de vídeo)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="c1dc2-182">Reduzir número de polylines</span><span class="sxs-lookup"><span data-stu-id="c1dc2-182">Reduce poly count</span></span>
<span data-ttu-id="c1dc2-183">Contagens de polígono mais altas resultam em mais operações para a GPU e a redução do número de polígonos em sua cena reduzirá a quantidade de tempo para renderizar essa geometria.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="c1dc2-184">Também há outros fatores envolvidos no sombreamento da geometria que ainda pode ser cara, mas a contagem de polígonos é a métrica base para determinar o quão caro será a renderização de uma cena.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="c1dc2-185">Limite de extração</span><span class="sxs-lookup"><span data-stu-id="c1dc2-185">Limit overdraw</span></span>

<span data-ttu-id="c1dc2-186">O alto sobreempate ocorre quando vários objetos são processados, mas não são enviados para a tela, pois eles ficam ocultos por outro objeto occluding, geralmente mais próximo,.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="c1dc2-187">Imagine examinar uma parede que tinha várias salas e geometria por trás dela.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="c1dc2-188">Toda a geometria seria processada para renderização, mas apenas a parede opaca realmente precisa ser renderizada, pois ela occludes a exibição de todo o outro conteúdo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="c1dc2-189">Isso resulta em desperdício de operações que não são necessárias para a exibição atual.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="c1dc2-190">Sombreadores</span><span class="sxs-lookup"><span data-stu-id="c1dc2-190">Shaders</span></span>

<span data-ttu-id="c1dc2-191">Os sombreadores são programas pequenos que são executados na GPU e geralmente determinam duas etapas importantes na renderização:</span><span class="sxs-lookup"><span data-stu-id="c1dc2-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="c1dc2-192">quais vértices do objeto devem ser desenhados na tela e onde estão no espaço da tela (ou seja,</span><span class="sxs-lookup"><span data-stu-id="c1dc2-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="c1dc2-193">o sombreador de vértice)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-193">the Vertex shader)</span></span>
    - <span data-ttu-id="c1dc2-194">O sombreador de vértice geralmente é executado por vértice para cada gameobject</span><span class="sxs-lookup"><span data-stu-id="c1dc2-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="c1dc2-195">o que colorir esses pixels (ou seja,</span><span class="sxs-lookup"><span data-stu-id="c1dc2-195">what to color those pixels (i.e</span></span> <span data-ttu-id="c1dc2-196">o sombreador de pixel)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-196">the Pixel shader)</span></span>
    - <span data-ttu-id="c1dc2-197">O sombreador de pixel é executado por pixel para a textura que está sendo renderizada para o dispositivo presente</span><span class="sxs-lookup"><span data-stu-id="c1dc2-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="c1dc2-198">Normalmente, os sombreadores executam muitas transformações e cálculos de iluminação.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="c1dc2-199">Embora modelos de iluminação complexos, sombras e outras operações possam gerar resultados fantásticos, eles também têm um preço.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="c1dc2-200">Reduzir o número de operações computadas em sombreadores pode reduzir muito o trabalho geral necessário para ser feito por uma GPU por quadro.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="c1dc2-201">Recomendações de codificação de sombreador</span><span class="sxs-lookup"><span data-stu-id="c1dc2-201">Shader coding recommendations</span></span>

- <span data-ttu-id="c1dc2-202">Use a filtragem biline sempre que possível</span><span class="sxs-lookup"><span data-stu-id="c1dc2-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="c1dc2-203">Reorganize as expressões para usar o MAD intrínsecos a fim de fazer uma multiplicação e uma adição ao mesmo tempo</span><span class="sxs-lookup"><span data-stu-id="c1dc2-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="c1dc2-204">Precalcule o máximo possível na CPU e passe como constantes para o material</span><span class="sxs-lookup"><span data-stu-id="c1dc2-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="c1dc2-205">**Favorecer operações de movimentação do sombreador de pixel para o sombreador de vértice**</span><span class="sxs-lookup"><span data-stu-id="c1dc2-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="c1dc2-206">Geralmente, o número de vértices < < # de pixels (ou seja,</span><span class="sxs-lookup"><span data-stu-id="c1dc2-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="c1dc2-207">720p = = 921.600 pixels, 1080p = = 2.073.600 pixels, etc.)</span><span class="sxs-lookup"><span data-stu-id="c1dc2-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="c1dc2-208">Remover estágios de GPU</span><span class="sxs-lookup"><span data-stu-id="c1dc2-208">Remove GPU stages</span></span>
<span data-ttu-id="c1dc2-209">Os efeitos de pós-processamento podem ser muito caros e geralmente inibim a taxa de preenchimento do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="c1dc2-210">Isso também inclui técnicas de suavização de alias, como MSAA.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="c1dc2-211">No HoloLens, é recomendável evitar essas técnicas inteiramente.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="c1dc2-212">Além disso, os estágios adicionais do sombreador, como Geometry, envoltória e sombreadores de computação, devem ser evitados quando possível.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="c1dc2-213">Recomendações de memória</span><span class="sxs-lookup"><span data-stu-id="c1dc2-213">Memory recommendations</span></span>
<span data-ttu-id="c1dc2-214">A alocação de memória excessiva & as operações de desalocação podem ter efeitos adversos em seu aplicativo Holographic, resultando em desempenho inconsistente, quadros congelados e outros comportamentos prejudiciais.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="c1dc2-215">É especialmente importante entender as considerações de memória ao desenvolver no Unity, uma vez que o gerenciamento de memória é controlado pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="c1dc2-216">Pooling de objetos</span><span class="sxs-lookup"><span data-stu-id="c1dc2-216">Object pooling</span></span>

<span data-ttu-id="c1dc2-217">O pooling de objetos é uma técnica popular para reduzir o custo de alocações contínuas & desalocações de objetos.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="c1dc2-218">Isso é feito alocando um grande pool de objetos idênticos e reutilizando instâncias disponíveis inativas desse pool em vez de constantemente gerar e destruir objetos ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="c1dc2-219">Os pools de objetos são ótimos para componentes reutilizados que têm tempo de vida variável durante um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c1dc2-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="c1dc2-220">Consulte também</span><span class="sxs-lookup"><span data-stu-id="c1dc2-220">See also</span></span>
- [<span data-ttu-id="c1dc2-221">Recomendações de desempenho para Unity</span><span class="sxs-lookup"><span data-stu-id="c1dc2-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="c1dc2-222">Configurações recomendadas do Unity</span><span class="sxs-lookup"><span data-stu-id="c1dc2-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
