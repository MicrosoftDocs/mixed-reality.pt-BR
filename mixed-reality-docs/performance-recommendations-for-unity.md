---
title: Recomendações de desempenho para Unity
description: Dicas de específicas do Unity para melhorar o desempenho com aplicativos de realidade misturada.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: elementos gráficos, cpu, gpu, renderização, coleta de lixo, hololens
ms.openlocfilehash: 37eac566a0315009330ac7fee96edd82348d6ba3
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/12/2019
ms.locfileid: "59590982"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="82131-104">Recomendações de desempenho para Unity</span><span class="sxs-lookup"><span data-stu-id="82131-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="82131-105">Este artigo se baseia na discussão descrita [recomendações de desempenho para realidade misturada](understanding-performance-for-mixed-reality.md) mas enfatiza os conhecimentos específicos do ambiente de mecanismo do Unity.</span><span class="sxs-lookup"><span data-stu-id="82131-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="82131-106">Também é altamente recomendável que os desenvolvedores examinar a [configurações de ambiente para o artigo do Unity recomendadas](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="82131-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="82131-107">Este artigo possui conteúdo com algumas das configurações mais importantes de cena no que diz respeito à criação de aplicativos de realidade mista de alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="82131-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="82131-108">Algumas dessas configurações recomendadas estão destacadas abaixo também.</span><span class="sxs-lookup"><span data-stu-id="82131-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="82131-109">Como criar um perfil com o Unity</span><span class="sxs-lookup"><span data-stu-id="82131-109">How to profile with Unity</span></span>

<span data-ttu-id="82131-110">Unity fornece a **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** interna que é um ótimo recurso para coletar informações de desempenho valioso para seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="82131-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="82131-111">Embora o criador de perfil no editor pode ser executada, essas métricas não representam o ambiente de tempo de execução true e dessa forma, os resultados deste devem ser usados com cautela.</span><span class="sxs-lookup"><span data-stu-id="82131-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="82131-112">É recomendável para o perfil remotamente seu aplicativo durante a execução no dispositivo para obter informações mais precisas e acionáveis.</span><span class="sxs-lookup"><span data-stu-id="82131-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="82131-113">Além disso, do Unity [quadro depurador](https://docs.unity3d.com/Manual/FrameDebugger.html) também é muito eficiente e ferramenta de análise de utilizar.</span><span class="sxs-lookup"><span data-stu-id="82131-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="82131-114">Unity fornece excelente documentação para:</span><span class="sxs-lookup"><span data-stu-id="82131-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="82131-115">Como conectar-se a [Unity profiler para aplicativos UWP remotamente](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="82131-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="82131-116">Como efetivamente [diagnosticar problemas de desempenho com o Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="82131-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="82131-117">Com o Profiler Unity conectado e depois de adicionar o criador de perfil GPU (consulte *Profiler adicionar* no canto superior direito), é possível ver quanto tempo é gasto na CPU e GPU respectivamente no meio do criador de perfil.</span><span class="sxs-lookup"><span data-stu-id="82131-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="82131-118">Isso permite que o desenvolvedor obter uma aproximação rápida se seu aplicativo é a CPU ou GPU limitado.</span><span class="sxs-lookup"><span data-stu-id="82131-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU do Unity vs GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="82131-120">Recomendações de desempenho de CPU</span><span class="sxs-lookup"><span data-stu-id="82131-120">CPU performance recommendations</span></span>

<span data-ttu-id="82131-121">O conteúdo abaixo aborda mais práticas abrangentes de desempenho, especialmente orientadas para Unity & C# desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="82131-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="82131-122">Referências de cache</span><span class="sxs-lookup"><span data-stu-id="82131-122">Cache references</span></span>

<span data-ttu-id="82131-123">É uma prática recomendada para referências de cache para todos os componentes relevantes e GameObjects na inicialização.</span><span class="sxs-lookup"><span data-stu-id="82131-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="82131-124">Isso ocorre porque, como chamadas de função de repetição *[GetComponent\<T > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* são significativamente mais caro em relação à custo para armazenar um ponteiro de memória.</span><span class="sxs-lookup"><span data-stu-id="82131-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="82131-125">Isso também se aplica a para o bastante, regularmente usada [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="82131-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="82131-126">*Camera.main* , na verdade, apenas utiliza *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* sob qual forma mais barata pesquisará seu grafo de cena para um objeto de câmera com a *"MainCamera"*  marca.</span><span class="sxs-lookup"><span data-stu-id="82131-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] <span data-ttu-id="82131-127">Evite GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="82131-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="82131-128">Ao usar  *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, há uma série de sobrecargas diferentes.</span><span class="sxs-lookup"><span data-stu-id="82131-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="82131-129">É importante usar sempre as implementações de tipo com base e nunca a sobrecarga de pesquisa com base em cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="82131-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="82131-130">Pesquisar pela cadeia de caracteres na sua cena é significativamente mais caro do que a pesquisa por tipo.</span><span class="sxs-lookup"><span data-stu-id="82131-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="82131-131">(BOM) Componente GetComponent (tipo)</span><span class="sxs-lookup"><span data-stu-id="82131-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="82131-132">(BOM) T GetComponent\<T >)</span><span class="sxs-lookup"><span data-stu-id="82131-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="82131-133">(Inválido) Componente GetComponent(string) ></span><span class="sxs-lookup"><span data-stu-id="82131-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="82131-134">Evite operações dispendiosas</span><span class="sxs-lookup"><span data-stu-id="82131-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="82131-135">**Evite o uso de [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="82131-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="82131-136">Embora o LINQ pode ser muito claro e fácil de ler e gravar, ele geralmente requer computação muito mais e mais particularmente alocação de memória do que escrever o algoritmo manualmente.</span><span class="sxs-lookup"><span data-stu-id="82131-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="82131-137">**APIs comuns do Unity**</span><span class="sxs-lookup"><span data-stu-id="82131-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="82131-138">Determinadas APIs do Unity, embora úteis, pode ser muito caro para executar.</span><span class="sxs-lookup"><span data-stu-id="82131-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="82131-139">A maioria delas envolve pesquisando seu grafo de cena inteira para alguma lista correspondente de GameObjects.</span><span class="sxs-lookup"><span data-stu-id="82131-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="82131-140">Essas operações geralmente podem ser evitadas com referências de cache ou implementar um componente do Gerenciador de GameObjects em questão acompanhar as referências em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="82131-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="82131-141">*[SendMessage](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)*  e *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* deve ser eliminado a todo custo.</span><span class="sxs-lookup"><span data-stu-id="82131-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="82131-142">Essas funções podem ser na ordem de 1000 x mais lento do que chamadas de função direta.</span><span class="sxs-lookup"><span data-stu-id="82131-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="82131-143">**Lembre-se de conversão boxing**</span><span class="sxs-lookup"><span data-stu-id="82131-143">**Beware of boxing**</span></span>

    <span data-ttu-id="82131-144">[Conversão boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) é um conceito fundamental do C# idioma e o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="82131-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="82131-145">Ele é o processo de quebra automática de variáveis de tipo de valor, como char, int, bool, etc. em variáveis do tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="82131-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="82131-146">Quando uma variável de tipo de valor é "demarcada", ele é encapsulado dentro de um System. Object, que é armazenado na heap gerenciada.</span><span class="sxs-lookup"><span data-stu-id="82131-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="82131-147">Portanto, a memória é alocada e, eventualmente, quando descartado devem ser processadas pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="82131-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="82131-148">Essas alocações e desalocações incorrer um custo de desempenho e em muitos cenários são desnecessárias ou podem ser facilmente substituídas por uma alternativa mais barata.</span><span class="sxs-lookup"><span data-stu-id="82131-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

#### <a name="repeating-code-paths"></a><span data-ttu-id="82131-149">Caminhos de código de repetição</span><span class="sxs-lookup"><span data-stu-id="82131-149">Repeating code paths</span></span>

<span data-ttu-id="82131-150">Quaisquer funções de retorno de chamada de Unity (isto é, repetição</span><span class="sxs-lookup"><span data-stu-id="82131-150">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="82131-151">Atualização) que são executadas várias vezes por segundo e/ou quadro deve ser escrito com muito cuidado.</span><span class="sxs-lookup"><span data-stu-id="82131-151">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="82131-152">Quaisquer operações dispendiosas aqui terá consistente e enorme impacto no desempenho.</span><span class="sxs-lookup"><span data-stu-id="82131-152">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="82131-153">**Funções de retorno vazia**</span><span class="sxs-lookup"><span data-stu-id="82131-153">**Empty callback functions**</span></span>

    <span data-ttu-id="82131-154">Embora o código a seguir pode parecer inocente para deixar no seu aplicativo, especialmente porque cada Unity script automático inicializa com este bloco de código, esses retornos de chamada vazios podem, na verdade, tornam-se muito caros.</span><span class="sxs-lookup"><span data-stu-id="82131-154">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="82131-155">Unity funciona e para trás ao longo de um limite de código não gerenciado/gerenciado, entre o código de UnityEngine e o código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="82131-155">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="82131-156">Essa ponte troca de contexto é relativamente caro, mesmo se não houver nada a executar.</span><span class="sxs-lookup"><span data-stu-id="82131-156">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="82131-157">Isso se torna especialmente problemático se seu aplicativo tiver centenas de GameObjects com componentes que têm retornos de chamada de Unity repetição vazios.</span><span class="sxs-lookup"><span data-stu-id="82131-157">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="82131-158">Update () é a manifestação mais comum desse problema de desempenho, mas outros retornos de chamada do Unity repetitivos, como a seguir podem ser igualmente tão ruim se não é pior: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span><span class="sxs-lookup"><span data-stu-id="82131-158">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="82131-159">**Operações para favorecer a executar uma vez por quadro**</span><span class="sxs-lookup"><span data-stu-id="82131-159">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="82131-160">As seguintes APIs do Unity são operações comuns para muitos aplicativos Holographic.</span><span class="sxs-lookup"><span data-stu-id="82131-160">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="82131-161">Embora não é sempre possível, os resultados dessas funções muito comum podem ser calculados uma vez e os resultados novamente utilizados no aplicativo para um determinado período.</span><span class="sxs-lookup"><span data-stu-id="82131-161">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="82131-162">a) geralmente é recomendável ter uma classe Singleton ou um serviço para manipular seu foco Raycast na cena e, em seguida, reutilizar esse resultado em todos os outros componentes de cena, em vez de fazer essencialmente idênticas e repetidas operações de Raycast por cada dedicado componente.</span><span class="sxs-lookup"><span data-stu-id="82131-162">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="82131-163">Obviamente, alguns aplicativos podem exigir raycasts de origens diferentes ou em relação a diferentes [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="82131-163">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="82131-164">b) evitar operações GetComponent() nos retornos de chamada de Unity repetidas, como Update () por [referências de cache](#cache-references) em Start () ou Awake()</span><span class="sxs-lookup"><span data-stu-id="82131-164">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="82131-165">c) é uma boa prática para criar uma instância de todos os objetos, se possível, na inicialização e usar [pool de objetos](#object-pooling) reciclagem e reutilização GameObjects ao longo do tempo de execução do seu aplicativo</span><span class="sxs-lookup"><span data-stu-id="82131-165">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="82131-166">**Evite interfaces e construções virtuais**</span><span class="sxs-lookup"><span data-stu-id="82131-166">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="82131-167">Invocando chamadas de função por meio de interfaces vs direct objetos ou chamar funções virtuais às vezes podem ser muito mais caros do que utiliza construções diretas ou chamadas de função direta.</span><span class="sxs-lookup"><span data-stu-id="82131-167">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="82131-168">Se a função virtual ou a interface é desnecessária, ela deverá ser removida.</span><span class="sxs-lookup"><span data-stu-id="82131-168">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="82131-169">No entanto, o desempenho de ocorrências para essas abordagens são geralmente que vale a pena a compensação se utilizar-os simplifica a colaboração de desenvolvimento, a legibilidade do código e manutenção de código.</span><span class="sxs-lookup"><span data-stu-id="82131-169">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span> 

4) <span data-ttu-id="82131-170">**Evite structs de passagem por valor**</span><span class="sxs-lookup"><span data-stu-id="82131-170">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="82131-171">Diferentemente das classes, structs são tipos de valor e quando passados diretamente para uma função, seu conteúdo é copiado para uma instância recém-criada.</span><span class="sxs-lookup"><span data-stu-id="82131-171">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="82131-172">Essa cópia adiciona custo, bem como memória adicional na pilha de CPU.</span><span class="sxs-lookup"><span data-stu-id="82131-172">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="82131-173">Para structs pequeno, o efeito é geralmente muito mínima e, portanto, é aceitável.</span><span class="sxs-lookup"><span data-stu-id="82131-173">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="82131-174">No entanto, para as funções chamadas repetidamente a cada quadro, bem como funções que levam a grandes structs, se possível modificar a definição de função para passar por referência.</span><span class="sxs-lookup"><span data-stu-id="82131-174">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="82131-175">Saiba mais aqui</span><span class="sxs-lookup"><span data-stu-id="82131-175">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="82131-176">Diversos</span><span class="sxs-lookup"><span data-stu-id="82131-176">Miscellaneous</span></span>

1) <span data-ttu-id="82131-177">**Física**</span><span class="sxs-lookup"><span data-stu-id="82131-177">**Physics**</span></span>

    <span data-ttu-id="82131-178">a) em geral, a maneira mais fácil para melhorar a física é limitar a quantidade de tempo gasto em física ou o número de iterações por segundo.</span><span class="sxs-lookup"><span data-stu-id="82131-178">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="82131-179">Obviamente, isso reduzirá precisão de simulação.</span><span class="sxs-lookup"><span data-stu-id="82131-179">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="82131-180">Ver [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) no Unity</span><span class="sxs-lookup"><span data-stu-id="82131-180">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="82131-181">b) o tipo de colisores no Unity ter características de desempenho muito diferentes.</span><span class="sxs-lookup"><span data-stu-id="82131-181">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="82131-182">A ordem a seguir lista as maioria dos colisores alto desempenho para menos colisores de alto desempenho da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="82131-182">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="82131-183">É muito importante evitar Colisores de malha que são significativamente mais caro do que o primitivos colisores.</span><span class="sxs-lookup"><span data-stu-id="82131-183">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="82131-184">Ver [práticas recomendadas do Unity física](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) para obter mais informações</span><span class="sxs-lookup"><span data-stu-id="82131-184">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="82131-185">**Animações**</span><span class="sxs-lookup"><span data-stu-id="82131-185">**Animations**</span></span>

    <span data-ttu-id="82131-186">Desabilitar animações ociosas, desabilitando o componente Animator (desabilitar o objeto do jogo não terá o mesmo efeito).</span><span class="sxs-lookup"><span data-stu-id="82131-186">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="82131-187">Evite os padrões de design onde um animator se encontra em um loop de definir um valor para a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="82131-187">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="82131-188">Há uma sobrecarga considerável para essa técnica, sem afetar o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="82131-188">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="82131-189">Saiba mais aqui.</span><span class="sxs-lookup"><span data-stu-id="82131-189">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="82131-190">**Algoritmos complexos**</span><span class="sxs-lookup"><span data-stu-id="82131-190">**Complex algorithms**</span></span>

    <span data-ttu-id="82131-191">Se seu aplicativo está usando algoritmos complexos como cinemática inversa, a localização do caminho, etc, procure para localizar uma abordagem mais simples ou ajustar as configurações relevantes para o desempenho</span><span class="sxs-lookup"><span data-stu-id="82131-191">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="82131-192">Recomendações de desempenho de CPU para GPU</span><span class="sxs-lookup"><span data-stu-id="82131-192">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="82131-193">Em geral, o desempenho de CPU para GPU é fornecido para baixo até a **chamadas de desenho** enviado para a placa gráfica.</span><span class="sxs-lookup"><span data-stu-id="82131-193">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="82131-194">Para melhorar o desempenho, chamadas de desenho precisam ser estrategicamente **a) reduzido** ou **b) reestruturados** para obter melhores resultados.</span><span class="sxs-lookup"><span data-stu-id="82131-194">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="82131-195">Como as chamadas de desenho em si são intensivo de recursos, reduzindo-os reduzirá trabalho geral necessário.</span><span class="sxs-lookup"><span data-stu-id="82131-195">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="82131-196">Além disso, estado é alterado entre chamadas de desenho exige validação dispendiosa e etapas de conversão no driver de gráficos e assim, reestruturação de chamadas de desenho do seu aplicativo para limitar as alterações de estado (ou seja,</span><span class="sxs-lookup"><span data-stu-id="82131-196">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="82131-197">materiais diferentes, etc.) pode melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="82131-197">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="82131-198">Unity tem um ótimo artigo que fornece uma visão geral e mergulha envio em lote as chamadas de desenho para a plataforma deles.</span><span class="sxs-lookup"><span data-stu-id="82131-198">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="82131-199">Unity desenhar a chamada de envio em lote</span><span class="sxs-lookup"><span data-stu-id="82131-199">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="82131-200">Renderização de instância única passagem</span><span class="sxs-lookup"><span data-stu-id="82131-200">Single pass instanced rendering</span></span>

<span data-ttu-id="82131-201">Passagem única Instanced renderização no Unity permite chamadas de desenho para cada olho seja reduzido para baixo até a chamada de um desenho instanciado.</span><span class="sxs-lookup"><span data-stu-id="82131-201">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="82131-202">Devido a coerência de cache entre as duas chamadas de desenho, também há alguma melhoria de desempenho na GPU também.</span><span class="sxs-lookup"><span data-stu-id="82131-202">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="82131-203">Para habilitar esse recurso em seu projeto do Unity</span><span class="sxs-lookup"><span data-stu-id="82131-203">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="82131-204">Abra **configurações do Player XR** (acesse **editar** > **configurações do projeto** > **Player**  >  **XR configurações**)</span><span class="sxs-lookup"><span data-stu-id="82131-204">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="82131-205">Selecione **instância única de passar** da **estéreo de método de renderização** menu suspenso (**suporte de realidade Virtual** caixa de seleção deve ser marcada)</span><span class="sxs-lookup"><span data-stu-id="82131-205">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="82131-206">Leia os seguintes artigos do Unity para obter detalhes com essa abordagem de renderização.</span><span class="sxs-lookup"><span data-stu-id="82131-206">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="82131-207">Como maximizar o desempenho de AR e VR com renderização estéreo avançada</span><span class="sxs-lookup"><span data-stu-id="82131-207">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="82131-208">Instanciação de passagem única</span><span class="sxs-lookup"><span data-stu-id="82131-208">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="82131-209">Um problema comum com a única passar instância renderização ocorre se os desenvolvedores têm já existente de sombreadores personalizados não escritos para criação de instância.</span><span class="sxs-lookup"><span data-stu-id="82131-209">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="82131-210">Depois de habilitar esse recurso, os desenvolvedores podem perceber a renderização de apenas alguns GameObjects em um olho.</span><span class="sxs-lookup"><span data-stu-id="82131-210">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="82131-211">Isso ocorre porque os sombreadores personalizados associados não tem as propriedades adequadas para criação de instância.</span><span class="sxs-lookup"><span data-stu-id="82131-211">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="82131-212">Ver [único passar estéreo de renderização para HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) do Unity para resolver esse problema</span><span class="sxs-lookup"><span data-stu-id="82131-212">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="82131-213">Envio em lote estático</span><span class="sxs-lookup"><span data-stu-id="82131-213">Static batching</span></span>

<span data-ttu-id="82131-214">Unity é capaz de muitos objetos estáticos para reduzir as chamadas de desenho para a GPU do lote.</span><span class="sxs-lookup"><span data-stu-id="82131-214">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="82131-215">Envio em lote estático funciona para a maioria [renderizador](https://docs.unity3d.com/ScriptReference/Renderer.html) objetos no Unity que **1) compartilham o mesmo material** e **2) são todos marcado como *estático***  ( Selecione um objeto no Unity e clique na caixa de seleção no canto superior direito da inspeção de).</span><span class="sxs-lookup"><span data-stu-id="82131-215">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="82131-216">GameObjects marcados como *estático* não podem ser movidos ao longo do tempo de execução do seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="82131-216">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="82131-217">Assim, envio em lote estático pode ser difícil aproveitar o HoloLens, onde praticamente todo objeto precisa ser colocada, movidos, dimensionada, etc. Para fones imersivos em exposição, o envio em lote estático pode reduzir drasticamente as chamadas de desenho e, portanto, melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="82131-217">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="82131-218">Leia *envio em lote estáticos* sob [desenhar chamar envio em lote no Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="82131-218">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="82131-219">Envio em lote dinâmico</span><span class="sxs-lookup"><span data-stu-id="82131-219">Dynamic batching</span></span>

<span data-ttu-id="82131-220">Uma vez que é problemático para marcar objetos como *estático* para desenvolvimento HoloLens, envio em lote dinâmico pode ser uma excelente ferramenta para compensar isso na falta de recurso.</span><span class="sxs-lookup"><span data-stu-id="82131-220">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="82131-221">Naturalmente, é possível também ser útil em fones imersivos em exposição também.</span><span class="sxs-lookup"><span data-stu-id="82131-221">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="82131-222">Envio em lote dinâmico no Unity pode ser difícil entanto habilitar porque GameObjects deve **a) compartilhar o mesmo Material** e **b) atender a uma longa lista de outros critérios**.</span><span class="sxs-lookup"><span data-stu-id="82131-222">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="82131-223">Leia *envio em lote dinâmico* sob [desenhar chamar envio em lote no Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obter a lista completa.</span><span class="sxs-lookup"><span data-stu-id="82131-223">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="82131-224">Mais comumente, GameObjects se tornar inválidos a ser agrupadas dinamicamente, como os dados de malha associado podem ser vértices não mais do que 300.</span><span class="sxs-lookup"><span data-stu-id="82131-224">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="82131-225">outras técnicas</span><span class="sxs-lookup"><span data-stu-id="82131-225">Other techniques</span></span>

<span data-ttu-id="82131-226">Envio em lote só pode ocorrer se vários GameObjects são capazes de compartilhar o mesmo material.</span><span class="sxs-lookup"><span data-stu-id="82131-226">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="82131-227">Normalmente, isso será bloqueado pela necessidade de GameObjects ter uma textura exclusiva para seu respectivo Material.</span><span class="sxs-lookup"><span data-stu-id="82131-227">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="82131-228">É comum para combinar texturas em uma textura grande, um método conhecido como [textura Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="82131-228">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="82131-229">Além disso, é geralmente preferível para combinar as malhas em um GameObject onde possível e razoável.</span><span class="sxs-lookup"><span data-stu-id="82131-229">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="82131-230">Cada renderizador no Unity terá associou chamadas de desenho versus enviando uma malha combinada em um renderizador.</span><span class="sxs-lookup"><span data-stu-id="82131-230">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span> 

>[!NOTE]
> <span data-ttu-id="82131-231">Modificando as propriedades de Renderer.material em tempo de execução criará uma cópia do Material e, portanto, potencialmente quebrar envio em lote.</span><span class="sxs-lookup"><span data-stu-id="82131-231">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="82131-232">Use Renderer.sharedMaterial para modificar as propriedades de material compartilhadas em GameObjects.</span><span class="sxs-lookup"><span data-stu-id="82131-232">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="82131-233">Recomendações de desempenho de GPU</span><span class="sxs-lookup"><span data-stu-id="82131-233">GPU performance recommendations</span></span>

<span data-ttu-id="82131-234">Saiba mais sobre [otimizando a renderização de gráficos no Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="82131-234">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="82131-235">Reduzir a contagem de poly</span><span class="sxs-lookup"><span data-stu-id="82131-235">Reduce poly count</span></span>

<span data-ttu-id="82131-236">Contagem de polígono geralmente é reduzida em qualquer uma</span><span class="sxs-lookup"><span data-stu-id="82131-236">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="82131-237">Removendo objetos de uma cena</span><span class="sxs-lookup"><span data-stu-id="82131-237">Removing objects from a scene</span></span>
2) <span data-ttu-id="82131-238">Eliminação de ativo que reduz o número de polígonos para uma determinada malha</span><span class="sxs-lookup"><span data-stu-id="82131-238">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="82131-239">Implementando uma [sistema de nível de detalhe (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) em seu aplicativo que renderiza objetos com versão inferior polígono da mesma geometria de distância</span><span class="sxs-lookup"><span data-stu-id="82131-239">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="82131-240">Limite de excedente</span><span class="sxs-lookup"><span data-stu-id="82131-240">Limit overdraw</span></span>

<span data-ttu-id="82131-241">No Unity, um pode exibir exceda sua cena, ativando/desativando o [ **desenhar o menu modo** ](https://docs.unity3d.com/Manual/ViewModes.html) no canto superior esquerdo do **exibição cena** e selecionando **excedentes** .</span><span class="sxs-lookup"><span data-stu-id="82131-241">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="82131-242">Em geral, excedente podem ser reduzidas pela remoção de objetos de antecedência antes de serem enviadas à GPU.</span><span class="sxs-lookup"><span data-stu-id="82131-242">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="82131-243">Unity fornece detalhes sobre a implementação [oclusão traseira](https://docs.unity3d.com/Manual/OcclusionCulling.html) seu mecanismo.</span><span class="sxs-lookup"><span data-stu-id="82131-243">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

#### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="82131-244">Sombreadores de Noções básicas sobre no Unity</span><span class="sxs-lookup"><span data-stu-id="82131-244">Understanding shaders in Unity</span></span>

<span data-ttu-id="82131-245">Uma aproximação fácil comparar sombreadores no desempenho é identificar o número médio de operações de cada executa em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="82131-245">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="82131-246">Isso pode ser feito facilmente no Unity.</span><span class="sxs-lookup"><span data-stu-id="82131-246">This can be done fairly easily in Unity.</span></span>

1) <span data-ttu-id="82131-247">Selecione seu ativo de sombreador ou selecione um material, no canto superior direito da janela do Inspetor, selecione o ícone de engrenagem e, em seguida, **"Selecione sombreador"**</span><span class="sxs-lookup"><span data-stu-id="82131-247">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Selecione o sombreador no Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="82131-249">Com o ativo de sombreador selecionado, clique o **"Compilar e mostrar código"** botão sob a janela Inspetor</span><span class="sxs-lookup"><span data-stu-id="82131-249">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilar o código de sombreador no Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="82131-251">Após a compilação, procure a seção de estatísticas nos resultados com o número de operações diferentes para o sombreador de vértices e de pixel (Observação: sombreadores de pixel geralmente também são chamados de sombreadores de fragmento)</span><span class="sxs-lookup"><span data-stu-id="82131-251">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operações de padrão de sombreador do Unity](images/unity-standard-shader-compilation.png)

##### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="82131-253">Alternativas de padrão de sombreador do Unity</span><span class="sxs-lookup"><span data-stu-id="82131-253">Unity Standard shader alternatives</span></span>

<span data-ttu-id="82131-254">Em vez de usar uma renderização fisicamente com base (PBR) ou outro sombreador de alta qualidade, examinar utilizando um mais eficazes e mais barato do sombreador.</span><span class="sxs-lookup"><span data-stu-id="82131-254">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="82131-255">[Misto Toolkit realidade](https://github.com/Microsoft/MixedRealityToolkit-Unity) fornece uma [sombreador padrão](https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/mrtk_release/Assets/MixedRealityToolkit/StandardAssets/Shaders/MixedRealityStandard.shader) que foi otimizado para projetos de realidade misturada.</span><span class="sxs-lookup"><span data-stu-id="82131-255">[Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides a [standard shader](https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/mrtk_release/Assets/MixedRealityToolkit/StandardAssets/Shaders/MixedRealityStandard.shader) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="82131-256">Unity também oferece um apagada, vértice aceso, opções de sombreador simplificada difusa e outras que são significativamente mais rápida quando comparadas ao sombreador padrão do Unity.</span><span class="sxs-lookup"><span data-stu-id="82131-256">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="82131-257">Ver [uso e desempenho de sombreadores interno](https://docs.unity3d.com/Manual/shader-Performance.html) para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="82131-257">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="82131-258">Recomendações de memória</span><span class="sxs-lookup"><span data-stu-id="82131-258">Memory recommendations</span></span>

<span data-ttu-id="82131-259">Operações de alocação e desalocação de memória excessiva podem ter efeitos adversos no seu aplicativo holográfico, resultando em desempenho inconsistente, quadros congelados e outro comportamento prejudicial.</span><span class="sxs-lookup"><span data-stu-id="82131-259">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="82131-260">É especialmente importante entender as considerações de memória durante o desenvolvimento no Unity, uma vez que o gerenciamento de memória é controlado pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="82131-260">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="82131-261">Coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="82131-261">Garbage collection</span></span>

<span data-ttu-id="82131-262">Aplicativos holográfico perderá tempo de computação de processamento para o coletor de lixo (GC) quando o GC é ativado para analisar os objetos que não estão mais no escopo durante a execução e sua memória precisa ser liberado para que ele pode ser disponibilizado para reutilização.</span><span class="sxs-lookup"><span data-stu-id="82131-262">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="82131-263">Desalocações e alocações constante geralmente exigirá o coletor de lixo executar com mais frequência, portanto, prejudicar o desempenho e experiência do usuário.</span><span class="sxs-lookup"><span data-stu-id="82131-263">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="82131-264">Unity forneceu uma excelente página que explica detalhadamente como funciona o coletor de lixo e dicas para escrever um código mais eficiente em relação ao gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="82131-264">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="82131-265">Otimizando a coleta de lixo em jogos do Unity</span><span class="sxs-lookup"><span data-stu-id="82131-265">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="82131-266">Uma das práticas mais comuns que leva à coleta de lixo excessiva não está armazenando em cache as referências a componentes e classes no desenvolvimento do Unity.</span><span class="sxs-lookup"><span data-stu-id="82131-266">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="82131-267">Todas as referências devem ser capturadas durante Start () ou Awake() e reutilizadas em funções posteriores como Update () ou LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="82131-267">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="82131-268">Outras dicas rápidas:</span><span class="sxs-lookup"><span data-stu-id="82131-268">Other quick tips:</span></span>
- <span data-ttu-id="82131-269">Use o [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# classe para criar dinamicamente as cadeias de caracteres complexas em tempo de execução</span><span class="sxs-lookup"><span data-stu-id="82131-269">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="82131-270">Remover chamadas para Debug.Log() quando não for mais necessário conforme forem executadas ainda em todas as versões de compilação de um aplicativo</span><span class="sxs-lookup"><span data-stu-id="82131-270">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="82131-271">Se seu aplicativo holográfico geralmente requer muita memória, considere a possibilidade de chamar [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante o carregamento fases, como ao apresentar um carregamento ou tela de transição</span><span class="sxs-lookup"><span data-stu-id="82131-271">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="82131-272">Ao pool de objetos</span><span class="sxs-lookup"><span data-stu-id="82131-272">Object pooling</span></span>

<span data-ttu-id="82131-273">Pool de objetos é uma técnica popular para reduzir o custo de contínuas alocações e Desalocações de objetos.</span><span class="sxs-lookup"><span data-stu-id="82131-273">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="82131-274">Isso é feito por alocar um grande pool de objetos idênticos e reutilização de instâncias inativas, disponíveis desse pool em vez de constantemente gerando e destruição de objetos ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="82131-274">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="82131-275">Pools de objeto são ótimos para componentes novamente utilizáveis que têm vida útil da variável durante a um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="82131-275">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="82131-276">Objeto de pool de Tutorial no Unity</span><span class="sxs-lookup"><span data-stu-id="82131-276">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="82131-277">Desempenho de inicialização</span><span class="sxs-lookup"><span data-stu-id="82131-277">Startup performance</span></span>

<span data-ttu-id="82131-278">Você deve considerar iniciar seu aplicativo com uma cena menor e, em seguida, usando *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* para carregar o restante da cena.</span><span class="sxs-lookup"><span data-stu-id="82131-278">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="82131-279">Isso permite que seu aplicativo chegar a um estado interativo tão rápido quanto possível.</span><span class="sxs-lookup"><span data-stu-id="82131-279">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="82131-280">Estar ciente de que poderá haver um grande aumento de CPU enquanto a nova cena está sendo ativada e qualquer conteúdo renderizado pode "gagueje" ou qualquer contratempo.</span><span class="sxs-lookup"><span data-stu-id="82131-280">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="82131-281">Uma maneira de solucionar esse problema é definir a propriedade AsyncOperation.allowSceneActivation como false na cena que está sendo carregada, aguarde até que a cena carregar, limpar a tela para preto e, em seguida, defina novamente como verdadeiro para concluir a ativação da cena.</span><span class="sxs-lookup"><span data-stu-id="82131-281">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="82131-282">Lembre-se de que, enquanto a cena de inicialização está carregando a tela inicial holográfica será exibida ao usuário.</span><span class="sxs-lookup"><span data-stu-id="82131-282">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="82131-283">Consulte também</span><span class="sxs-lookup"><span data-stu-id="82131-283">See also</span></span>
- [<span data-ttu-id="82131-284">Otimizando a renderização de gráficos em jogos do Unity</span><span class="sxs-lookup"><span data-stu-id="82131-284">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="82131-285">Otimizando a coleta de lixo em jogos do Unity</span><span class="sxs-lookup"><span data-stu-id="82131-285">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="82131-286">[Práticas recomendadas de física [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="82131-286">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="82131-287">[Otimizando Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="82131-287">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
